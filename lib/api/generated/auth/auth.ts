/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Personal Finance API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  TokenResponse,
  UserLoginRequest,
  UserRegisterRequest,
  UserResponse,
  WalletCreateRequest,
  WalletResponse,
  WalletUpdateRequest
} from '.././model';

import { customInstance } from '../../client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Register a new user.
 * @summary Register
 */
export const registerApiV1AuthRegisterPost = (
    userRegisterRequest: UserRegisterRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserResponse>(
      {url: `/api/v1/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userRegisterRequest, signal
    },
      options);
    }
  


export const getRegisterApiV1AuthRegisterPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserRegisterRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserRegisterRequest}, TContext> => {

const mutationKey = ['registerApiV1AuthRegisterPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, {data: UserRegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  registerApiV1AuthRegisterPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterApiV1AuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>>
    export type RegisterApiV1AuthRegisterPostMutationBody = UserRegisterRequest
    export type RegisterApiV1AuthRegisterPostMutationError = HTTPValidationError

    /**
 * @summary Register
 */
export const useRegisterApiV1AuthRegisterPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserRegisterRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>,
        TError,
        {data: UserRegisterRequest},
        TContext
      > => {

      const mutationOptions = getRegisterApiV1AuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Login user and return access token.
 * @summary Login
 */
export const loginApiV1AuthLoginPost = (
    userLoginRequest: UserLoginRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenResponse>(
      {url: `/api/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userLoginRequest, signal
    },
      options);
    }
  


export const getLoginApiV1AuthLoginPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: UserLoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: UserLoginRequest}, TContext> => {

const mutationKey = ['loginApiV1AuthLoginPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, {data: UserLoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  loginApiV1AuthLoginPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginApiV1AuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>>
    export type LoginApiV1AuthLoginPostMutationBody = UserLoginRequest
    export type LoginApiV1AuthLoginPostMutationError = HTTPValidationError

    /**
 * @summary Login
 */
export const useLoginApiV1AuthLoginPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: UserLoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
        TError,
        {data: UserLoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginApiV1AuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get current user information.
 * @summary Get Current User Info
 */
export const getCurrentUserInfoApiV1AuthMeGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserResponse>(
      {url: `/api/v1/auth/me`, method: 'GET', signal
    },
      options);
    }
  



export const getGetCurrentUserInfoApiV1AuthMeGetQueryKey = () => {
    return [
    `/api/v1/auth/me`
    ] as const;
    }

    
export const getGetCurrentUserInfoApiV1AuthMeGetQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserInfoApiV1AuthMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>> = ({ signal }) => getCurrentUserInfoApiV1AuthMeGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserInfoApiV1AuthMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>>
export type GetCurrentUserInfoApiV1AuthMeGetQueryError = unknown


export function useGetCurrentUserInfoApiV1AuthMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserInfoApiV1AuthMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserInfoApiV1AuthMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Current User Info
 */

export function useGetCurrentUserInfoApiV1AuthMeGet<TData = Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserInfoApiV1AuthMeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserInfoApiV1AuthMeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all wallets for current user.
 * @summary Get Wallets
 */
export const getWalletsApiV1WalletsGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WalletResponse[]>(
      {url: `/api/v1/wallets`, method: 'GET', signal
    },
      options);
    }
  



export const getGetWalletsApiV1WalletsGetQueryKey = () => {
    return [
    `/api/v1/wallets`
    ] as const;
    }

    
export const getGetWalletsApiV1WalletsGetQueryOptions = <TData = Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWalletsApiV1WalletsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>> = ({ signal }) => getWalletsApiV1WalletsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWalletsApiV1WalletsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>>
export type GetWalletsApiV1WalletsGetQueryError = unknown


export function useGetWalletsApiV1WalletsGet<TData = Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>,
          TError,
          Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWalletsApiV1WalletsGet<TData = Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>,
          TError,
          Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWalletsApiV1WalletsGet<TData = Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Wallets
 */

export function useGetWalletsApiV1WalletsGet<TData = Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWalletsApiV1WalletsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWalletsApiV1WalletsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new wallet.
 * @summary Create Wallet
 */
export const createWalletApiV1WalletsPost = (
    walletCreateRequest: WalletCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WalletResponse>(
      {url: `/api/v1/wallets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: walletCreateRequest, signal
    },
      options);
    }
  


export const getCreateWalletApiV1WalletsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWalletApiV1WalletsPost>>, TError,{data: WalletCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createWalletApiV1WalletsPost>>, TError,{data: WalletCreateRequest}, TContext> => {

const mutationKey = ['createWalletApiV1WalletsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createWalletApiV1WalletsPost>>, {data: WalletCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createWalletApiV1WalletsPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateWalletApiV1WalletsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createWalletApiV1WalletsPost>>>
    export type CreateWalletApiV1WalletsPostMutationBody = WalletCreateRequest
    export type CreateWalletApiV1WalletsPostMutationError = HTTPValidationError

    /**
 * @summary Create Wallet
 */
export const useCreateWalletApiV1WalletsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createWalletApiV1WalletsPost>>, TError,{data: WalletCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createWalletApiV1WalletsPost>>,
        TError,
        {data: WalletCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateWalletApiV1WalletsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get wallet by ID.
 * @summary Get Wallet
 */
export const getWalletApiV1WalletsWalletIdGet = (
    walletId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WalletResponse>(
      {url: `/api/v1/wallets/${walletId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetWalletApiV1WalletsWalletIdGetQueryKey = (walletId?: number,) => {
    return [
    `/api/v1/wallets/${walletId}`
    ] as const;
    }

    
export const getGetWalletApiV1WalletsWalletIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError = HTTPValidationError>(walletId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWalletApiV1WalletsWalletIdGetQueryKey(walletId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>> = ({ signal }) => getWalletApiV1WalletsWalletIdGet(walletId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(walletId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWalletApiV1WalletsWalletIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>>
export type GetWalletApiV1WalletsWalletIdGetQueryError = HTTPValidationError


export function useGetWalletApiV1WalletsWalletIdGet<TData = Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError = HTTPValidationError>(
 walletId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>,
          TError,
          Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWalletApiV1WalletsWalletIdGet<TData = Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError = HTTPValidationError>(
 walletId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>,
          TError,
          Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWalletApiV1WalletsWalletIdGet<TData = Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError = HTTPValidationError>(
 walletId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Wallet
 */

export function useGetWalletApiV1WalletsWalletIdGet<TData = Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError = HTTPValidationError>(
 walletId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWalletApiV1WalletsWalletIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWalletApiV1WalletsWalletIdGetQueryOptions(walletId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update wallet.
 * @summary Update Wallet
 */
export const updateWalletApiV1WalletsWalletIdPatch = (
    walletId: number,
    walletUpdateRequest: WalletUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<WalletResponse>(
      {url: `/api/v1/wallets/${walletId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: walletUpdateRequest
    },
      options);
    }
  


export const getUpdateWalletApiV1WalletsWalletIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWalletApiV1WalletsWalletIdPatch>>, TError,{walletId: number;data: WalletUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateWalletApiV1WalletsWalletIdPatch>>, TError,{walletId: number;data: WalletUpdateRequest}, TContext> => {

const mutationKey = ['updateWalletApiV1WalletsWalletIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateWalletApiV1WalletsWalletIdPatch>>, {walletId: number;data: WalletUpdateRequest}> = (props) => {
          const {walletId,data} = props ?? {};

          return  updateWalletApiV1WalletsWalletIdPatch(walletId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateWalletApiV1WalletsWalletIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateWalletApiV1WalletsWalletIdPatch>>>
    export type UpdateWalletApiV1WalletsWalletIdPatchMutationBody = WalletUpdateRequest
    export type UpdateWalletApiV1WalletsWalletIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update Wallet
 */
export const useUpdateWalletApiV1WalletsWalletIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateWalletApiV1WalletsWalletIdPatch>>, TError,{walletId: number;data: WalletUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateWalletApiV1WalletsWalletIdPatch>>,
        TError,
        {walletId: number;data: WalletUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateWalletApiV1WalletsWalletIdPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete wallet.
 * @summary Delete Wallet
 */
export const deleteWalletApiV1WalletsWalletIdDelete = (
    walletId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/wallets/${walletId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteWalletApiV1WalletsWalletIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWalletApiV1WalletsWalletIdDelete>>, TError,{walletId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteWalletApiV1WalletsWalletIdDelete>>, TError,{walletId: number}, TContext> => {

const mutationKey = ['deleteWalletApiV1WalletsWalletIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWalletApiV1WalletsWalletIdDelete>>, {walletId: number}> = (props) => {
          const {walletId} = props ?? {};

          return  deleteWalletApiV1WalletsWalletIdDelete(walletId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteWalletApiV1WalletsWalletIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWalletApiV1WalletsWalletIdDelete>>>
    
    export type DeleteWalletApiV1WalletsWalletIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Wallet
 */
export const useDeleteWalletApiV1WalletsWalletIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWalletApiV1WalletsWalletIdDelete>>, TError,{walletId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteWalletApiV1WalletsWalletIdDelete>>,
        TError,
        {walletId: number},
        TContext
      > => {

      const mutationOptions = getDeleteWalletApiV1WalletsWalletIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    